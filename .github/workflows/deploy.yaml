name: Deploy to Amazon ECS

on:
  workflow_run:
    # Triggers on successful completion of build-and-push workflow
    workflows: ["Build and Push Images to ECR"]
    types: [completed]
  # Allows manual triggering of the actions workflow from the Actions tab
  workflow_dispatch:
    # Specify image tag to be deployed when manually triggering workflow
    inputs:
      tag:
        description: "Provide image tag for manual deployment (e.g. 1.0.0-prod-abc1234)"
        required: true

permissions:
  # Allowed by default but good to be explicit and follow least privilege
  contents: read

env:
  # Save registry as global env variable to keep DRY
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # Define matrix with different config for backend and frontend services.
        # This allows deployment in parallel, without repeating duplicate steps
        service: [backend, frontend]
        include:
          # Define backend specific variables
          - service: backend
            container_port: ${{ vars.BACKEND_PORT }}
            environment-variables: |
              [
                {"name": "NODE_ENV", "value": "production"},
                {"name": "TOKEN_HEADER_KEY", "value":"${{ vars.TOKEN_HEADER_KEY }}"}
              ]
            # Vars used here resolve to ARN's so safe to use as vars not secrets
            secrets: |
              [
                {"name": "DATABASE_URI", "valueFrom": "${{ vars.SSM_DB_URI_ARN }}"},
                {"name": "JWT_SECRET_KEY", "valueFrom": "${{ vars.SSM_JWT_KEY_ARN }}"},
                {"name": "OMDB_API_KEY", "valueFrom": "${{ vars.SSM_OMDB_KEY_ARN }}"}
              ]
            memory: ${{ vars.BACKEND_MEMORY }}
            security-groups: ${{ vars.BACKEND_SECURITY_GROUPS }}
            health-check-path: ${{ vars.BACKEND_HEALTH_CHECK_PATH }}
          # Define frontend specific variables
          - service: frontend
            container_port: ${{ vars.FRONTEND_PORT }}
            memory: ${{ vars.FRONTEND_MEMORY }}
            security-groups: ${{ vars.FRONTEND_SECURITY_GROUPS }}
            health-check-path: ${{ vars.FRONTEND_HEALTH_CHECK_PATH }}

    # Only run if manually dispatched or build-and-push workflow succeeded
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}

    steps:
      # Configure AWS credentials using IAM user with appropriate permissions to access ECR
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Download tag artifact from build-and-push workflow
      - name: Download Tag Artifact
        # Only download if triggered automatically not manually
        if: github.event_name == 'workflow_run'
        uses: actions/download-artifact@v7
        with:
          # Require github token to access artifacts from another workflow
          github-token: ${{ secrets.GITHUB_TOKEN }}
          name: tag
          run-id: ${{ github.event.workflow_run.id }}
          # Download artifact to root
          path: .

      # Get image tag from tag artifact or manual input if triggered manually
      - name: Get Image Tag
        id: get_tag
        run: |
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_run" ]]; then
            TAG=$(cat tag.txt)
          else
            TAG="${{ github.event.inputs.tag }}"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Image tag: $TAG"

      # Deploy both services using ECS deploy express action and matrix variables for configuration
      - name: Deploy Services to ECS
        id: deploy-service
        uses: aws-actions/amazon-ecs-deploy-express-service@v1
        with:
          # Required inputs
          service-name: ${{ vars.SERVICE_NAME }}-${{ matrix.service }}-service
          image: ${{ env.ECR_REGISTRY }}/${{ vars.SERVICE_NAME }}/${{ matrix.service }}:${{ steps.get_tag.outputs.tag }}
          execution-role-arn: ${{ secrets.ECS_EXECUTION_ROLE_ARN }}
          infrastructure-role-arn: ${{ secrets.ECS_INFRASTRUCTURE_ROLE_ARN }}
          # Service identification
          cluster: ${{ vars.SERVICE_NAME }}-cluster
          # Container configuration
          container-port: ${{ matrix.container_port }}
          environment-variables: ${{ matrix.environment-variables }}
          secrets: ${{ matrix.secrets }}
          tags: |
            Environment=Production
            Application=${{ vars.SERVICE_NAME }}
            Service=${{ matrix.service }}
          # Resource configuration
          cpu: ${{ vars.CPU }}
          memory: ${{ matrix.memory }}
          # Network configuration
          subnets: ${{ vars.SUBNETS }}
          security-groups: ${{ matrix.security-groups }}
          # Service configuration
          health-check-path: ${{ matrix.health-check-path }}
          # Auto scaling configuration
          min-task-count: ${{ vars.MIN_TASK_COUNT }}
          max-task-count: ${{ vars.MAX_TASK_COUNT }}
          auto-scaling-metric: ${{ vars.AUTO_SCALING_METRIC }}
          auto-scaling-target-value: ${{ vars.AUTO_SCALING_TARGET }}

      # Get backend endpoint
      - name: Print Service Endpoints
        run: |
          echo "${{ matrix.service }} successfully deployed!"
          echo "${{ matrix.service }} endpoint: ${{ steps.deploy-service.outputs.endpoint }}"
